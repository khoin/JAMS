<!DOCTYPE html>
<html>
<head>
	<title>Render Test</title>
	<script src="./lib/core.render.js"></script>
	<script src="./lib/interface.js"></script>
	<script src="./lib/core.plugins.js"></script>
	<style type="text/css">
		html, body { width: 100%; height: 100%; overflow: hidden; padding: 0; margin: 0; }
	</style>
</head>
<body>
<script>
'use strict';

var Emsys = function() {
	if( !(this instanceof Emsys) ) return new Emsys();

	this.display = new Render({width: innerWidth, height: innerHeight});

	// stuff
	this.ioDisplayHeight = 20;
	this.ioDisplayWidth  = 10;

	this.moduleCounter = 0;
	this.modulesVisual = [];
	this.modulesAudial = [];

	// interactivity
	this.currentModule = undefined;
	this.currentOutput = undefined;
	this.currentInput  = undefined;
	// Current mouse positions
	this.cmx = 0;
	this.cmy = 0;

	// Audio
	this.aC = new AudioContext();
	this.processor = this.aC.createScriptProcessor(2048, 0, 1);
	this.t = 0;

	this.outputNode = this.createModule(innerWidth-100, 100, EmsysOutput);
}

Emsys.prototype.init = function() {
	var _ = this;

	// Audio stuff
	this.processor.connect(_.aC.destination);
	this.processor.onaudioprocess = function(audioProcessingEvent) {
		var obuffer = audioProcessingEvent.outputBuffer;
		var incr = obuffer.length/_.aC.sampleRate;
		for( var ch=0; ch < obuffer.numberOfChannels; ch++ ){
			var odata = obuffer.getChannelData(ch);
			for(var i=0; i<obuffer.length; i++) {
				odata[i] = _.audioLoop(_.t + (i/_.aC.sampleRate) );
			}
		}
		_.t += incr;
	}

	// inject UI into DOM
	this.display.appendTo(document.body);

	// constantly updating mouse position
	_.display.DOMElement.addEventListener("mousemove", e => {
		_.cmx = e.clientX;
		_.cmy = e.clientY;
	});

	// mousedown on app
	this.display.DOMElement.addEventListener("mousedown", e => {
		// m is for mouse (NOT module!)
		let mx = e.clientX;
		let my = e.clientY;

		// walks through all modules and see if the mouse is on it or not
		_.modulesVisual.some( module => {
			if( mx > module.x && mx < module.x+module.info.width && my > module.y && my < module.y+module.info.height ) {
				_.currentModule = module.id;

				// when it's over a module's output
				if( mx > module.x + module.info.width - _.ioDisplayWidth && my < module.y + module.info.numberOfOutputs*_.ioDisplayHeight ) {
					_.currentOutput = Math.floor( (my - module.y)/ _.ioDisplayHeight );
					return true;
				}

				// Shift Drag Event
				if(e.shiftKey == true) {
					_.display.DOMElement.addEventListener("mousemove", mouseShiftDragModuleHandler);
					return true;
				}

				// Normal Drag Event
				_.display.DOMElement.addEventListener("mousemove", mouseDragModuleHandler);
				return true;
			}
		})
	});

	// mouseup on app -- remove listeners -- connect 
	this.display.DOMElement.addEventListener("mouseup", e => {
		// m is for mouse (NOT module!)
		let mx = e.clientX;
		let my = e.clientY;

		// walk though each module
		_.modulesVisual.some( module => {
			if( mx > module.x && mx < module.x + _.ioDisplayWidth && my > module.y && my < module.y + module.info.numberOfInputs*_.ioDisplayHeight ) {
				
				_.currentInput = Math.floor( (my - module.y)/ _.ioDisplayHeight );
				if( _.currentOutput !== undefined ) {
				 	if( app.isConnectionExist(_.currentModule, _.currentOutput, module.id, _.currentInput) ) {
				 		app.disconnectModule( module.id, _.currentInput );
				 	} else {
						app.connectModule(_.currentModule, _.currentOutput, module.id, _.currentInput);
				 	}
				}
				return true;
			}
		})

		_.currentInput  = undefined;
		_.currentOutput = undefined;

		// remove listeners for drag events
		_.display.DOMElement.removeEventListener("mousemove", mouseShiftDragModuleHandler);
		_.display.DOMElement.removeEventListener("mousemove", mouseDragModuleHandler);
	});

	// move currently selected module
	this.display.DOMElement.addEventListener("keydown", e => {
		var index = _.currentModule;
		var accl = ~~e.shiftKey << 2;
		switch(e.key.toLowerCase()) {
			case 'a':
				_.modulesVisual[index].x -= 1 + accl;
				return;
			case 'd':
				_.modulesVisual[index].x += 1 + accl;
				return;
			case 'w':
				_.modulesVisual[index].y -= 1 + accl;
				return;
			case 's':
				_.modulesVisual[index].y += 1 + accl;
				return;
		}
	});


	function mouseDragModuleHandler(e) { 
		_.modulesVisual[_.currentModule].x += e.movementX;
		_.modulesVisual[_.currentModule].y += e.movementY;
	}

	// shiftDrag means throw the event to module's drag handler
	function mouseShiftDragModuleHandler(e) { 
		_.modulesAudial[_.currentModule].handleDrag(e);
	}

	// fire rendering loop
	(function loop() {
		requestAnimationFrame(loop);
		_.renderLoop();
	})();
}

Emsys.prototype.audioLoop = function(t) {
	this.modulesAudial.forEach( module => {
		if(module.info.requestPrerun == true) module.run(t);
	});

	return this.modulesAudial[this.outputNode].run(t);
}

Emsys.prototype.renderLoop = function(w) {
	let _ = this;
	// we'll need this for offset. height is never negative (and we're in an integer environment), so it is reasonably safe to do a bit shift division. 
	let ioDisplayHalfHeight = _.ioDisplayHeight >> 1;

	_.display.background("#001");

	_.display.context.fillStyle = "white";

	// render the user's probable connection
	if( _.currentOutput !== undefined ) {
		let cmod = _.modulesVisual[_.currentModule];
		_.display.line(cmod.x + cmod.info.width, cmod.y + ioDisplayHalfHeight + _.currentOutput * _.ioDisplayHeight, _.cmx, _.cmy );
	}

	// render the modules
	this.modulesVisual.forEach( module => {
		let audioModule = _.modulesAudial[module.id];

		// draw module box 
		_.display.context.fillStyle = `hsl(${module.info.color}, 90%, ${ (module.id==_.currentModule)? 60:80 }%)`;
		_.display.box(module.x, module.y, module.info.width, module.info.height);

		// inputs
			for(let i=0; i<module.info.numberOfInputs ; i++) 
				_.display.box(module.x, module.y + i*_.ioDisplayHeight, _.ioDisplayWidth, _.ioDisplayHeight);
		// output
			for(let i=0; i<module.info.numberOfOutputs; i++) 
				_.display.box(module.x + module.info.width-_.ioDisplayWidth, module.y+i*_.ioDisplayHeight, _.ioDisplayWidth, _.ioDisplayHeight);
		
		// connections
			for(let i=0; i<audioModule.inputs.length; i++) { 
				//skip unplugged inputs
				if(audioModule.inputs[i] == undefined) continue;

				let targetNode = _.modulesVisual[audioModule.inputs[i].id];
				_.display.line(
					module.x,
					module.y + ioDisplayHalfHeight + _.ioDisplayHeight*i,
					targetNode.x + targetNode.info.width,
					targetNode.y + ioDisplayHalfHeight + _.ioDisplayHeight*audioModule.inputs[i].index);
			}

		// render module interface
			audioModule.interface(_.display, { x: module.x+10, y: module.y } );

	});

}

Emsys.prototype.createModule = function(x, y, module) { 
	this.modulesAudial[this.moduleCounter] = new module(this.moduleCounter);
	this.modulesVisual[this.moduleCounter] = {
		id: this.moduleCounter,
		x: x, y: y,
		info: this.modulesAudial[this.moduleCounter].info,
	};

	this.moduleCounter++;
	return this.moduleCounter-1;
}

Emsys.prototype.connectModule = function(source, sourceIndex, target, targetIndex) { 
	this.modulesAudial[source].connect( this.modulesAudial[target], targetIndex, sourceIndex );
}

Emsys.prototype.disconnectModule = function(module, index) {
	this.modulesAudial[module].unsetInput(index);
}

Emsys.prototype.isConnectionExist = function( source, sourceIndex, target, targetIndex ) {
	var src;
	if( !(src = this.modulesAudial[target].inputs[targetIndex]) ) return false;
	return src.id == source && src.index == sourceIndex;
}

Emsys.prototype.setParam = function(module, param, value) {
	this.modulesAudial[module].setParam(param, value);
}


// ----

var app = new Emsys();

app.init();

for(let i = 1; i < 5; i++) app.createModule(200, 100*i, EmsysSineGenerator);

app.setParam(app.createModule(50,50, EmsysNumber), 0, 440);
for(let i = 2; i < 6; i++) { app.setParam(app.createModule(50, 100*i, EmsysNumber), 0, i); app.createModule(120, 100*i, EmsysMultiplier); }; 

</script>
</body>
</html>